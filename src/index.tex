\documentclass[final]{elteikthesis}[2025/03/25]

\usepackage{abstract}
\usepackage[newfloat]{minted}
\usepackage{dirtree}

\removefromtoclist[float]{lol}

\title{Git Chord: Git tárolók meta-állapotainak hatékony kezelése}
\date{2025}

\author{Horváth Dávid}
\degree{Programtervező Informatikus BSc}

\supervisor{Dr. Cserép Máté}
\affiliation{egyetemi adjunktus}

\university{Eötvös Loránd Tudományegyetem}
\faculty{Informatikai Kar}
\department{Programozáselmélet és Szoftvertechnológiai\\ Tanszék}
\city{Budapest}
\logo{elte_cimer_szines}

\addbibresource{references.bib}

\begin{document}

\documentlang{hungarian}

\listoftodos
\cleardoublepage

\maketitle

\renewcommand{\abstractname}{Témabejelentő}

\begin{abstract}
Szakdolgozatomban bemutatom a Git Chord programot és az ahhoz készített néhány további segédeszközt.
A Git Chord egy POSIX shellben írt kiterjesztés a Git
verziókezelő rendszerhez, amely konfigurálható módon lehetővé teszi egy helyi tároló elemeinek
(branchek, tagek, stb.)
aktuális állapotából összeálló konstelláció mentését és visszaállítását,
illetve ezeknek a mentett meta-állapotoknak a böngészését, törlését, migrálását, másokkal való megosztását.

A Git Chord kényelmesebb megoldást kínál a korábbi meta-állapotok visszaállítására,
mint a Git által beépítetten támogatott reflog.
A reflog továbbá csak a helyi tárolón használható,
míg a Git Chord mentett meta-állapotai könnyen megoszthatók,
például migráció, deployment, archiválás vagy akár segítségkérés céljából.

A mentett meta-állapotok technikailag a tárolón belüli
speciális brancheken elhelyezett, teljesen reguláris commitok,
melyek többedik parent commitokként is hivatkoznak a meta-állapot által rögzített, hordozandó commitokra.
Így minden szükséges függőség garantáltan szállításra kerül a meta-állapot commitjával együtt,
ugyanakkor a mentések pehelysúlyúak, valójában nem történik költséges duplikáció.

A parancssori program mellett a szakdolgozati munka része egy webes GUI,
valamint az előbbire épülő kiegészítők néhány elterjedt
általános asztali integrált fejlesztői környezethez (például VS Code, Eclipse).
Az egyes kiegészítők a közös főképernyő mellett
az adott IDE sajátosságaihoz igazított egyedi működéseket is tartalmaznak (context menük, akciók, stb.).
A programnak a szakdolgozati védés keretében történő bemutatása során
nagy részben a webes felületre támaszkodom majd.

A fejlesztői-üzemeltetői hétköznapok során történő felhasználási eseteken túl
kitérek a programnak a verziókezelő rendszerek oktatásában való lehetséges alkalmazására.
Ennek alapgondolata, hogy a hallgatók által
a saját helyi tárolójukon végzett lokális módosítások eredménye
az értékelő oktatóval könnyen megosztható a Git Chord által mentett meta-állapotként.
\end{abstract}

\tableofcontents
\cleardoublepage

\chapter{Bevezetés}

A verziókezelő rendszerek fő feladata,
hogy egy folyamatosan változó tartalomegyüttesnek (például egy szoftver forráskódjának)
az evolucióját megkönnyítsék, ennek a folyamatnak technikai keretet adjanak.
E tekintetben a legfontosabb ellátandó feladat minden bizonnyal az,
hogy a rendszer képes legyen eltárolni a tartalomegyüttes bizonyos jóváhagyott állapotainak sorát
Ez a régi rendszereken még fájlonként történt,
a modern rendszerekben azonban már a teljes tartalomegyüttes
egy-egy pillanatképe, snapshotja jelenti az atomi egységet.
Egy további alapvető feladat, amelyet egy ilyen rendszernek biztosítania kell, a konkurens fejlesztés támogatása.
A régi rendszerekben még egy-egy fájl központilag történő lockolása volt hivatott biztosítani azt,
hogy több fejlesztő ne írja fölül egymás munkáját.
A modern rendszerekben a konkurens fejlesztés külön ágakon, azaz brancheken párhuzamosan történik.

Jelenleg a legelterjedtebb verziókezelő a nyílt forráskódú Git.

[a git mentális modelljéről és adattárolásáról, ez a továbbiakhoz szükséges lesz]

-------------------

párhuzamos fejlesztés támogatása,
azaz annak menedzselése, hogy a forráskód különböző részein is dolgozni lehessen anélkül,
hogy egymásra kellene várni.


Egy \textit{verziókezelő rendszer} feladata, hogy valamilyen adott tartalom (például programkód)
folyamatos fejlesztését megkönnyítse, annak evolúcióját támogató technikai keretet biztosítson.
A verziókezelt tartalom újabb és újabb verziói egy időbeli sorba rendeződnek,
a verziók és a köztük lévő különbségek visszakövethetők,
az egyes állapotok szükség esetén visszaállíthatók.
Emellett a fejlesztés el is ágazhat,
ekkor az újabb verziók párhuzamosan futó \textit{branch}eken kerülnek tárolásra.
Az elágazó fejlesztési történet lineáris láncolat helyett tehát egy aciklikus gráf. 
A modern elosztott verziókezelőkben a branchek kezelésére igen szofisztikált eszköztár áll rendelkezésre;
az olyan műveletek, mint új branchek létrehozása, meglévők egyesítése,
váltás a branchek között,
vagy akár a történet visszamenőleges manipulációja
általában egyszerű parancsok végrehajtásával elvégezhetők.

Jelenleg a legelterjedtebb verziókezelő a nyílt forráskódú \textit{Git}.
Filozófiájához hozzátartozik,
hogy a teljes verziókezelési folyamatot a helyi gépen kell elvégezni,
ezt lehet majd szinkronizálni más gépekre, például egy központi szerverre.
Mind a Git szervert, mind a lokális másolatot tárolónak (repository),
vagy röviden \textit{repó}nak nevezzük.
A Git elosztott rendszer,
használatához nincs feltétlenül szükség központi tárolóra.
Egy módosításcsomag publikálása két lépésből áll.
Elsőként a \textit{commit} művelettel létrehozzuk az új tárolt állapotot (snapshot);
a bevett terminológia szerint ezt is commitnak nevezik.
[TODO: a commit tartalma]
Alapértelmezetten az aktuális branch mentett állapota egyúttal az újonnan létrejött commitra ugrik.
Második lépésben a \textit{push} művelettel publikálhatjuk az adott branch (vagy branchek) állapotát egy szerverre.
A két lépés egymástól független,
és gyakran számos több commit létrehozása is megtörténik lokálisan,
mire sor kerülne a push műveletre.
A brancheken kívül \textit{tag}ek is létrehozhatók,
ezek hasonlóak a branchekhez,
a fő különbség, hogy véglegesek:
ha egyszer létrehoztunk egy adott commitra mutató taget,
az a továbbiakban immutábilisen erre a commitra fog mutatni
(ha mégis mozgatni szeretnénk, törölni kell, majd újra létrehozni).
Valójában kétféle tag létezik,
[TODO: a kétféle tag]
Általában (bár ez megkerülhető) a fejlesztők a saját gépükön
egyszerre tárolják a teljes verziótörténetet,
beleértve a számukra érdekes brancheket, gyakran az összeset.
Amikor a \textit{clone} művelettel lemásolunk, leklónozunk egy repót,
alapértelmezetten az összes branch és tag letöltésre kerül a teljes történettel együtt.
[vagyis sok van, itt jön be a nehézség; kezdők...]
[meta-verziókezelés, bár egy elágazó gráf, mindig van egy pillanatnyi meta-állapot]

\cleardoublepage

\chapter{Felhasználói dokumentáció}

\section{A parancssori \texttt{git-chord} program használata}

\subsection{Alapvető információk}

POSIX shell, git, snapshotok, tárolási mód stb. felhasználói szemszögből

\subsection{Telepítés és alapvető kipróbálás}

Hello.

\subsection{Konfiguráció}

Hello.

\subsection{Snapshotok helyi kezelése}

Hello.

\subsection{Snapshotok megosztása}

Hello.

\subsection{Egyéb parancsok}

Hello.

\section{A Git Chord webes felületének használata}

Hello.

\cleardoublepage

\chapter{Fejlesztői dokumentáció}

\section{A parancssori \texttt{git-chord} program felépítése}

Repó felépítése:

\dirtree{%
.1 git-chord/.
.2 bin/.
.3 git-chord.
.2 completion/.
.3 git-chord-completion.bashrc.
.2 install/.
.3 install-*.sh.
.2 maintain/.
.3 *.sh.
.2 packaging/.
.3 ,,,.
.2 test/.
.3 ,,,.
.2 LICENSE.
.2 README.md.
.2 regen.sh.
}

POSIX-kompatibilis

Főszkript felépítése:

\begin{itemize}
    \item header
    \item definíciók
    \item segédfüggvények (string manipulation, arguments handling, YAML, file system, miscellaneous)
    \item beállítások, opciók és paraméterek feldolgozása, alparancs megállapítása
    \item formázók beállítása a kimenet-beállítások alapján
    \item az opcióktól is függő függvények
    \item (teljesen vagy feltételesen) repófüggetlen alparancsok kiszolgálása (help, version, default-kezelés stb.)
    \item git repó ellenőrzése
    \item repófüggő alparancsok kiszolgálása
\end{itemize}

A POSIX nem tartalmazza az \texttt{mktemp} (és így \texttt{mktemp -d}) stb. parancsokat, ezért:

\begin{listing}[H]
\begin{minted}{shell}
createTmpDir() (
    sysTmpDir="$TMPDIR"
    if [ -z "$sysTmpDir" ]; then
        sysTmpDir="/tmp"
    fi
    pathPrefix="${sysTmpDir}/git-chord.$( date '+%N' )"
    path="$pathPrefix"
    i='1'
    while [ -e "$path" ]; do
        path="${pathPrefix}."
        i=$(( i + 1 ))
    done
    mkdir -p "$path"
    printf '%s\n' "$path"
)
\end{minted}
\caption{Átmeneti könyvtár készítése, POSIX-kompatibilis}
\end{listing}

először:

\begin{listing}[H]
\begin{minted}{shell}
tempYamlFile1="$( mktemp )" # FIXME: mktemp is not POSIX
printf '%s\n' "$stateYaml1" > "$tempYamlFile1"
tempYamlFile2="$( mktemp )" # FIXME: mktemp is not POSIX
printf '%s\n' "$stateYaml2" > "$tempYamlFile2"
if checkTruthy "$configValue_color"; then
    diff -u -U3 --color "$tempYamlFile1" "$tempYamlFile2"
else
    diff -u -U3 "$tempYamlFile1" "$tempYamlFile2"
fi
rm "$tempYamlFile1"
rm "$tempYamlFile2"
\end{minted}
\caption{Átmeneti fájlok kezelése előtte}
\end{listing}

majd:

\begin{listing}[H]
\begin{minted}{shell}
tempDir="$( createTmpDir )"
tempYamlFile1="${tempDir}/state1.yaml"
printf '%s\n' "$stateYaml1" > "$tempYamlFile1"
tempYamlFile2="${tempDir}/state2.yaml"
printf '%s\n' "$stateYaml2" > "$tempYamlFile2"
if checkTruthy "$configValue_color"; then
    diff -u -U3 --color "$tempYamlFile1" "$tempYamlFile2"
else
    diff -u -U3 "$tempYamlFile1" "$tempYamlFile2"
fi
rm -R "$tempDir"
\end{minted}
\caption{Átmeneti fájlok kezelése utána}
\end{listing}

...

\begin{listing}[H]
\begin{minted}{shell}
while IFS= read -r configLine; do
    configValue="$( printf '%s\n' "$configLine" | cut -d ' ' -f 2- )"
    outVariableName="configValue_$( printf '%s\n' "$configLine" | cut -d ' ' -f 1 | tr '.' '_' )"
    eval "${outVariableName}='$( escapeValue "$configValue")'"
done <<EOF
$( printf '%s\n' "$config" )
EOF
\end{minted}
\caption{Eredeti eval loop}
\end{listing}

Javított:

\begin{listing}[H]
\begin{minted}{shell}
eval "$(
    printf '%s\n' "$config" | sed -E ':loop; s/^(\w+)\./\1_/; t loop' | while IFS=' ' read -r outVariableName configValue; do
        printf "configValue_%s='" "$outVariableName"
        escapeValue "$configValue"
        printf "'\n"
    done
)"
\end{minted}
\caption{Optimalizált eval loop}
\end{listing}

\section{A Git Chord webes felületének felépítése}

\cleardoublepage

\chapter{Összegzés és alkalmazások}

Hello.

\cleardoublepage

\appendix

\chapter{Teszteredmények}

Hello.

\cleardoublepage

\phantomsection
\addcontentsline{toc}{chapter}{\biblabel}
\printbibliography[title=\biblabel]
\cleardoublepage

\phantomsection
\addcontentsline{toc}{chapter}{\lstfigurelabel}
\listoffigures
\cleardoublepage

\phantomsection
\addcontentsline{toc}{chapter}{\lsttablelabel}
\listoftables
\cleardoublepage

\phantomsection
\addcontentsline{toc}{chapter}{\lstalgorithmlabel}
\listofalgorithms
\cleardoublepage

\phantomsection
\addcontentsline{toc}{chapter}{\lstcodelabel}
\lstlistoflistings
\cleardoublepage

\end{document}
